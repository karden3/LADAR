function D = generation_D (Nx, Nz, Nq, Np)

%   Данная программа моделирует оператор А,
%   по формулам (32), (67) из оригинальной статьи
%   можем коментировать соответствующие строки 
%   для реализации с учётом фазы и без
%   
%   Nx, Nz, Np, Nq - параметры, характерезующие размерность задачи
%   phi            - вектор фазовых ошибок, случайных от -pi до pi
%   D_phi          - вспомогательная матрица, которая учитывает ошибку фазы
%   H              - упоминается в статье, но взята, как единичная
%   D              - вспомогательная матрица, рассчитывается явно в (67)

N = Nx * Nz;...для упрощения выкладок
M = Np * Nq;...аналогично
    
D = zeros(M, N);...третья матрица для А
for m = 0:(M - 1)
    %это удобно для последующих выкладок
    for n = 0:(N - 1)
        %вместо прописывания 1:N
        a = exp(1i * (2 * pi / Nx) * mod(n, Nx) * mod(m, Nx));
        b = exp(1i * (2 * pi / N) * mod(n, Nx) * floor(m / Nx));...здесь и далее floor - "округляет вниз"
        c = exp(1i * (2 * pi / Nz) * floor(n / Nx) * floor(m / Nx));
        D(m + 1, n + 1) = a * b * c;...для наглядности разбил на 3 множителя, которые задаются выше
    end
end

end