function A = generation_A (Nx, Nz, Nq, Np)

%   Данная программа моделирует оператор А,
%   по формулам (32), (67) из оригинальной статьи
%   можем коментировать соответствующие строки 
%   для реализации с учётом фазы и без
%   
%   Nx, Nz, Np, Nq - параметры, характерезующие размерность задачи
%   phi            - вектор фазовых ошибок, случайных от -pi до pi
%   D_phi          - вспомогательная матрица, которая учитывает ошибку фазы
%   H              - упоминается в статье, но взята, как единичная
%   D              - вспомогательная матрица, рассчитывается явно в (67)

N = Nx * Nz;...для упрощения выкладок
M = Np * Nq;...аналогично
%   мог бы положить Nx = Nz = Np = Nq, но что если захотим релизовать
%   задачу с постановкой в прямоугольной области (?)
    
phi = zeros(Nq, Np);...зададим вектор фазовых ошибок
phi = generation_phi(Nq, Np);...здесь мы используем предварительно написанную функцию 

...A = D_phi * H * D (32)у
    
D_phi = zeros(M, M);...первая матрица для А
for i = 1:Nq
    for k = 1:Np
        m = (i - 1) * Np + k;...нам надо двигаться по диагонали и вот выражение для этого
        D_phi(m, m) = exp(-1i * phi(i, k));...по определению
    end
end 

H = eye(size(D_phi));...вторая матрица для А, по определению - единичная
%   мог бы и не задавать вовсе, но вдруг придётся учесть её после (?)
    
D = zeros(M, N);...третья матрица для А
for m = 0:(M - 1)
    %это удобно для последующих выкладок
    for n = 0:(N - 1)
        %вместо прописывания 1:N
        a = exp(1i * (2 * pi / Nx) * mod(n, Nx) * mod(m, Nx));
        b = exp(1i * (2 * pi / N) * mod(n, Nx) * floor(m / Nx));...здесь и далее floor - "округляет вниз"
        c = exp(1i * (2 * pi / Nz) * floor(n / Nx) * floor(m / Nx));
        D(m + 1, n + 1) = a * b * c;...для наглядности разбил на 3 множителя, которые задаются выше
    end
end

A = D_phi * H * D;...реализация с учётом фазы
%A = H * D;...реализация без учёта фазы
%   ненужное следует закомментировать

end



    

